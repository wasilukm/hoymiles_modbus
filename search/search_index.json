{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"hoymiles_modbus \u00b6 Python library for gathering data from Hoymiles microinverters. The library communicates with DTU (DTU-Pro) which is a proxy/monitoring device for microinverters. DTU should be connected via its Ethernet port and should have IP address assigned by DHCP server. Documentation: https://wasilukm.github.io/hoymiles_modbus GitHub: https://github.com/wasilukm/hoymiles_modbus PyPI: https://pypi.org/project/hoymiles_modbus/ Free software: MIT Features \u00b6 Communication via Modbus TCP Decode all microinverter status registers, which include information such as: current production total production today production temperature alarms status grid voltage and frequency Applications \u00b6 This library is for creating higher-level applications. If you are looking for such, check the following: Home Assistant integrations integration via MQTT Add-on Credits \u00b6 This package was created with Cookiecutter and the waynerv/cookiecutter-pypackage project template.","title":"Home"},{"location":"#hoymiles_modbus","text":"Python library for gathering data from Hoymiles microinverters. The library communicates with DTU (DTU-Pro) which is a proxy/monitoring device for microinverters. DTU should be connected via its Ethernet port and should have IP address assigned by DHCP server. Documentation: https://wasilukm.github.io/hoymiles_modbus GitHub: https://github.com/wasilukm/hoymiles_modbus PyPI: https://pypi.org/project/hoymiles_modbus/ Free software: MIT","title":"hoymiles_modbus"},{"location":"#features","text":"Communication via Modbus TCP Decode all microinverter status registers, which include information such as: current production total production today production temperature alarms status grid voltage and frequency","title":"Features"},{"location":"#applications","text":"This library is for creating higher-level applications. If you are looking for such, check the following: Home Assistant integrations integration via MQTT Add-on","title":"Applications"},{"location":"#credits","text":"This package was created with Cookiecutter and the waynerv/cookiecutter-pypackage project template.","title":"Credits"},{"location":"api/","text":"Top-level package for hoymiles_modbus. client \u00b6 Hoymiles Modbus client. CommunicationParams dataclass \u00b6 Low level pymodbus communication parameters. Source code in hoymiles_modbus/client.py class CommunicationParams : \"\"\"Low level pymodbus communication parameters.\"\"\" timeout : int = 3 \"\"\"Request timeout.\"\"\" retries : int = 3 \"\"\"Max number of retries per request.\"\"\" retry_on_empty : bool = False \"\"\"Retry if received an empty response.\"\"\" close_comm_on_error : bool = False \"\"\"Close connection on error\"\"\" strict : bool = True \"\"\"Strict timing, 1.5 character between requests.\"\"\" reconnect_delay : int = 60000 * 5 \"\"\"Delay in milliseconds before reconnecting.\"\"\" close_comm_on_error : bool dataclass-field \u00b6 Close connection on error reconnect_delay : int dataclass-field \u00b6 Delay in milliseconds before reconnecting. retries : int dataclass-field \u00b6 Max number of retries per request. retry_on_empty : bool dataclass-field \u00b6 Retry if received an empty response. strict : bool dataclass-field \u00b6 Strict timing, 1.5 character between requests. timeout : int dataclass-field \u00b6 Request timeout. HoymilesModbusTCP \u00b6 Hoymiles Modbus TCP client. Gather data from photovoltaic installation based on Hoymiles microinverters managed by Hoymiles DTU (like DTU-pro). The client communicates with DTU via Modbus TCP protocol. Source code in hoymiles_modbus/client.py class HoymilesModbusTCP : \"\"\"Hoymiles Modbus TCP client. Gather data from photovoltaic installation based on Hoymiles microinverters managed by Hoymiles DTU (like DTU-pro). The client communicates with DTU via Modbus TCP protocol. \"\"\" _MAX_MICROINVERTER_COUNT = 100 _NULL_MICROINVERTER = '000000000000' def __init__ ( self , host : str , port : int = 502 , microinverter_type : MicroinverterType = MicroinverterType . MI , unit_id : int = 1 ) -> None : \"\"\"Initialize the object. Arguments: host: DTU address port: target DTU modbus TCP port microinverter_type: Microinverter type, applies to all microinverters unit_id: Modbus unit ID \"\"\" self . _host : str = host self . _port : int = port self . _dtu_serial_number : str = '' self . _microinverter_data_struct : Type [ Union [ MISeriesMicroinverterData , HMSeriesMicroinverterData ]] if microinverter_type == MicroinverterType . MI : self . _microinverter_data_struct = MISeriesMicroinverterData elif microinverter_type == MicroinverterType . HM : self . _microinverter_data_struct = HMSeriesMicroinverterData else : raise ValueError ( 'Unsupported microinverter type:' , microinverter_type ) self . _unit_id = unit_id self . _comm_params : CommunicationParams = CommunicationParams () @property def comm_params ( self ) -> CommunicationParams : \"\"\"Low level communication parameters.\"\"\" return self . _comm_params def _get_client ( self ) -> ModbusTcpClient : return ModbusTcpClient ( self . _host , self . _port , framer = _CustomSocketFramer , ** asdict ( self . comm_params )) @staticmethod def _read_registers ( client : ModbusTcpClient , start_address , count , unit_id ): result = client . read_holding_registers ( start_address , count , unit = unit_id ) if result . isError (): raise result return result @property def microinverter_data ( self ) -> List [ Union [ MISeriesMicroinverterData , HMSeriesMicroinverterData ]]: \"\"\"Status data from all microinverters. Each `get` is a new request and data from the installation. \"\"\" data : List [ Union [ MISeriesMicroinverterData , HMSeriesMicroinverterData ]] = [] with self . _get_client () as client : for i in range ( self . _MAX_MICROINVERTER_COUNT ): start_address = i * 40 + 0x1000 result = self . _read_registers ( client , start_address , 20 , self . _unit_id ) microinverter_data = self . _microinverter_data_struct . unpack ( result . encode ()[ 1 : 41 ]) if microinverter_data . serial_number == self . _NULL_MICROINVERTER : break data . append ( microinverter_data ) return data @property def dtu ( self ) -> str : \"\"\"DTU serial number.\"\"\" if not self . _dtu_serial_number : with self . _get_client () as client : result = self . _read_registers ( client , 0x2000 , 3 , self . _unit_id ) self . _dtu_serial_number = _serial_number_t . unpack ( result . encode ()[ 1 ::]) return self . _dtu_serial_number @property def plant_data ( self ) -> PlantData : \"\"\"Plant status data. Each `get` is a new request and data from the installation. \"\"\" microinverter_data = self . microinverter_data data = PlantData ( self . dtu , microinverter_data = microinverter_data ) for microinverter in microinverter_data : if microinverter . link_status : data . pv_power += microinverter . pv_power data . today_production += microinverter . today_production data . total_production += microinverter . total_production if microinverter . alarm_code : data . alarm_flag = True return data comm_params : CommunicationParams property readonly \u00b6 Low level communication parameters. dtu : str property readonly \u00b6 DTU serial number. microinverter_data : List [ Union [ hoymiles_modbus . datatypes . MISeriesMicroinverterData , hoymiles_modbus . datatypes . HMSeriesMicroinverterData ]] property readonly \u00b6 Status data from all microinverters. Each get is a new request and data from the installation. plant_data : PlantData property readonly \u00b6 Plant status data. Each get is a new request and data from the installation. __init__ ( self , host , port = 502 , microinverter_type =< MicroinverterType . MI : 1 > , unit_id = 1 ) special \u00b6 Initialize the object. Parameters: Name Type Description Default host str DTU address required port int target DTU modbus TCP port 502 microinverter_type MicroinverterType Microinverter type, applies to all microinverters <MicroinverterType.MI: 1> unit_id int Modbus unit ID 1 Source code in hoymiles_modbus/client.py def __init__ ( self , host : str , port : int = 502 , microinverter_type : MicroinverterType = MicroinverterType . MI , unit_id : int = 1 ) -> None : \"\"\"Initialize the object. Arguments: host: DTU address port: target DTU modbus TCP port microinverter_type: Microinverter type, applies to all microinverters unit_id: Modbus unit ID \"\"\" self . _host : str = host self . _port : int = port self . _dtu_serial_number : str = '' self . _microinverter_data_struct : Type [ Union [ MISeriesMicroinverterData , HMSeriesMicroinverterData ]] if microinverter_type == MicroinverterType . MI : self . _microinverter_data_struct = MISeriesMicroinverterData elif microinverter_type == MicroinverterType . HM : self . _microinverter_data_struct = HMSeriesMicroinverterData else : raise ValueError ( 'Unsupported microinverter type:' , microinverter_type ) self . _unit_id = unit_id self . _comm_params : CommunicationParams = CommunicationParams () datatypes \u00b6 Data structures. HMSeriesMicroinverterData ( MISeriesMicroinverterData ) \u00b6 HM series microinverter status data structure. Source code in hoymiles_modbus/datatypes.py class HMSeriesMicroinverterData ( MISeriesMicroinverterData ): \"\"\"HM series microinverter status data structure.\"\"\" pv_current : Decimal = member ( fmt = _udec16p2 , doc = 'PV current [A].' ) pv_current : Decimal property writable \u00b6 PV current [A]. MISeriesMicroinverterData ( Structure ) \u00b6 MI series microinverter status data structure. Source code in hoymiles_modbus/datatypes.py class MISeriesMicroinverterData ( Structure ): \"\"\"MI series microinverter status data structure.\"\"\" data_type : int = member ( fmt = uint8 ) serial_number : str = member ( fmt = _serial_number_t , doc = 'Microinverter serial number.' ) port_number : int = member ( fmt = uint8 , doc = 'Port number.' ) pv_voltage : Decimal = member ( fmt = _udec16p1 , doc = 'PV voltage [V].' ) pv_current : Decimal = member ( fmt = _udec16p1 , doc = 'PV current [A].' ) grid_voltage : Decimal = member ( fmt = _udec16p1 , doc = 'Grid voltage [V].' ) grid_frequency : Decimal = member ( fmt = _udec16p2 , doc = 'Grid frequency [Hz].' ) pv_power : Decimal = member ( fmt = _udec16p1 , doc = 'PV power [W].' ) today_production : int = member ( fmt = uint16 , doc = 'Today production [Wh].' ) total_production : int = member ( fmt = uint32 , doc = 'Total production [Wh].' ) temperature : Decimal = member ( fmt = _sdec16p1 , doc = 'Microinverter temperature [\u00b0C].' ) operating_status : int = member ( fmt = uint16 , doc = 'Operating status.' ) alarm_code : int = member ( fmt = uint16 , doc = 'Alarm code.' ) alarm_count : int = member ( fmt = uint16 , doc = 'Alarm count.' ) link_status : int = member ( fmt = uint8 , doc = 'Link status.' ) reserved : List [ int ] = member ( fmt = _reserved ) alarm_code : int property writable \u00b6 Alarm code. alarm_count : int property writable \u00b6 Alarm count. grid_frequency : Decimal property writable \u00b6 Grid frequency [Hz]. grid_voltage : Decimal property writable \u00b6 Grid voltage [V]. link_status : int property writable \u00b6 Link status. operating_status : int property writable \u00b6 Operating status. port_number : int property writable \u00b6 Port number. pv_current : Decimal property writable \u00b6 PV current [A]. pv_power : Decimal property writable \u00b6 PV power [W]. pv_voltage : Decimal property writable \u00b6 PV voltage [V]. serial_number : str property writable \u00b6 Microinverter serial number. temperature : Decimal property writable \u00b6 Microinverter temperature [\u00b0C]. today_production : int property writable \u00b6 Today production [Wh]. total_production : int property writable \u00b6 Total production [Wh]. MicroinverterType ( Enum ) \u00b6 Microinverter type. Source code in hoymiles_modbus/datatypes.py class MicroinverterType ( Enum ): \"\"\"Microinverter type.\"\"\" MI = auto () \"\"\"MI series.\"\"\" HM = auto () \"\"\"HM series.\"\"\" HM \u00b6 HM series. MI \u00b6 MI series. PlantData dataclass \u00b6 Data structure for the whole plant. Source code in hoymiles_modbus/datatypes.py class PlantData : \"\"\"Data structure for the whole plant.\"\"\" dtu : str \"\"\"DTU serial number.\"\"\" pv_power : Decimal = Decimal ( 0 ) \"\"\"Current production [W].\"\"\" today_production : int = 0 \"\"\"Today production [Wh].\"\"\" total_production : int = 0 \"\"\"Total production [Wh].\"\"\" alarm_flag : bool = False \"\"\"Alarm indicator. True means that at least one microinverter reported an alarm.\"\"\" microinverter_data : List [ Union [ MISeriesMicroinverterData , HMSeriesMicroinverterData ]] = field ( default_factory = list ) \"\"\"Data for each microinverter.\"\"\" alarm_flag : bool dataclass-field \u00b6 Alarm indicator. True means that at least one microinverter reported an alarm. dtu : str dataclass-field \u00b6 DTU serial number. microinverter_data : List [ Union [ hoymiles_modbus . datatypes . MISeriesMicroinverterData , hoymiles_modbus . datatypes . HMSeriesMicroinverterData ]] dataclass-field \u00b6 Data for each microinverter. pv_power : Decimal dataclass-field \u00b6 Current production [W]. today_production : int dataclass-field \u00b6 Today production [Wh]. total_production : int dataclass-field \u00b6 Total production [Wh].","title":"Modules"},{"location":"api/#hoymiles_modbus.client","text":"Hoymiles Modbus client.","title":"client"},{"location":"api/#hoymiles_modbus.client.CommunicationParams","text":"Low level pymodbus communication parameters. Source code in hoymiles_modbus/client.py class CommunicationParams : \"\"\"Low level pymodbus communication parameters.\"\"\" timeout : int = 3 \"\"\"Request timeout.\"\"\" retries : int = 3 \"\"\"Max number of retries per request.\"\"\" retry_on_empty : bool = False \"\"\"Retry if received an empty response.\"\"\" close_comm_on_error : bool = False \"\"\"Close connection on error\"\"\" strict : bool = True \"\"\"Strict timing, 1.5 character between requests.\"\"\" reconnect_delay : int = 60000 * 5 \"\"\"Delay in milliseconds before reconnecting.\"\"\"","title":"CommunicationParams"},{"location":"api/#hoymiles_modbus.client.CommunicationParams.close_comm_on_error","text":"Close connection on error","title":"close_comm_on_error"},{"location":"api/#hoymiles_modbus.client.CommunicationParams.reconnect_delay","text":"Delay in milliseconds before reconnecting.","title":"reconnect_delay"},{"location":"api/#hoymiles_modbus.client.CommunicationParams.retries","text":"Max number of retries per request.","title":"retries"},{"location":"api/#hoymiles_modbus.client.CommunicationParams.retry_on_empty","text":"Retry if received an empty response.","title":"retry_on_empty"},{"location":"api/#hoymiles_modbus.client.CommunicationParams.strict","text":"Strict timing, 1.5 character between requests.","title":"strict"},{"location":"api/#hoymiles_modbus.client.CommunicationParams.timeout","text":"Request timeout.","title":"timeout"},{"location":"api/#hoymiles_modbus.client.HoymilesModbusTCP","text":"Hoymiles Modbus TCP client. Gather data from photovoltaic installation based on Hoymiles microinverters managed by Hoymiles DTU (like DTU-pro). The client communicates with DTU via Modbus TCP protocol. Source code in hoymiles_modbus/client.py class HoymilesModbusTCP : \"\"\"Hoymiles Modbus TCP client. Gather data from photovoltaic installation based on Hoymiles microinverters managed by Hoymiles DTU (like DTU-pro). The client communicates with DTU via Modbus TCP protocol. \"\"\" _MAX_MICROINVERTER_COUNT = 100 _NULL_MICROINVERTER = '000000000000' def __init__ ( self , host : str , port : int = 502 , microinverter_type : MicroinverterType = MicroinverterType . MI , unit_id : int = 1 ) -> None : \"\"\"Initialize the object. Arguments: host: DTU address port: target DTU modbus TCP port microinverter_type: Microinverter type, applies to all microinverters unit_id: Modbus unit ID \"\"\" self . _host : str = host self . _port : int = port self . _dtu_serial_number : str = '' self . _microinverter_data_struct : Type [ Union [ MISeriesMicroinverterData , HMSeriesMicroinverterData ]] if microinverter_type == MicroinverterType . MI : self . _microinverter_data_struct = MISeriesMicroinverterData elif microinverter_type == MicroinverterType . HM : self . _microinverter_data_struct = HMSeriesMicroinverterData else : raise ValueError ( 'Unsupported microinverter type:' , microinverter_type ) self . _unit_id = unit_id self . _comm_params : CommunicationParams = CommunicationParams () @property def comm_params ( self ) -> CommunicationParams : \"\"\"Low level communication parameters.\"\"\" return self . _comm_params def _get_client ( self ) -> ModbusTcpClient : return ModbusTcpClient ( self . _host , self . _port , framer = _CustomSocketFramer , ** asdict ( self . comm_params )) @staticmethod def _read_registers ( client : ModbusTcpClient , start_address , count , unit_id ): result = client . read_holding_registers ( start_address , count , unit = unit_id ) if result . isError (): raise result return result @property def microinverter_data ( self ) -> List [ Union [ MISeriesMicroinverterData , HMSeriesMicroinverterData ]]: \"\"\"Status data from all microinverters. Each `get` is a new request and data from the installation. \"\"\" data : List [ Union [ MISeriesMicroinverterData , HMSeriesMicroinverterData ]] = [] with self . _get_client () as client : for i in range ( self . _MAX_MICROINVERTER_COUNT ): start_address = i * 40 + 0x1000 result = self . _read_registers ( client , start_address , 20 , self . _unit_id ) microinverter_data = self . _microinverter_data_struct . unpack ( result . encode ()[ 1 : 41 ]) if microinverter_data . serial_number == self . _NULL_MICROINVERTER : break data . append ( microinverter_data ) return data @property def dtu ( self ) -> str : \"\"\"DTU serial number.\"\"\" if not self . _dtu_serial_number : with self . _get_client () as client : result = self . _read_registers ( client , 0x2000 , 3 , self . _unit_id ) self . _dtu_serial_number = _serial_number_t . unpack ( result . encode ()[ 1 ::]) return self . _dtu_serial_number @property def plant_data ( self ) -> PlantData : \"\"\"Plant status data. Each `get` is a new request and data from the installation. \"\"\" microinverter_data = self . microinverter_data data = PlantData ( self . dtu , microinverter_data = microinverter_data ) for microinverter in microinverter_data : if microinverter . link_status : data . pv_power += microinverter . pv_power data . today_production += microinverter . today_production data . total_production += microinverter . total_production if microinverter . alarm_code : data . alarm_flag = True return data","title":"HoymilesModbusTCP"},{"location":"api/#hoymiles_modbus.client.HoymilesModbusTCP.comm_params","text":"Low level communication parameters.","title":"comm_params"},{"location":"api/#hoymiles_modbus.client.HoymilesModbusTCP.dtu","text":"DTU serial number.","title":"dtu"},{"location":"api/#hoymiles_modbus.client.HoymilesModbusTCP.microinverter_data","text":"Status data from all microinverters. Each get is a new request and data from the installation.","title":"microinverter_data"},{"location":"api/#hoymiles_modbus.client.HoymilesModbusTCP.plant_data","text":"Plant status data. Each get is a new request and data from the installation.","title":"plant_data"},{"location":"api/#hoymiles_modbus.client.HoymilesModbusTCP.__init__","text":"Initialize the object. Parameters: Name Type Description Default host str DTU address required port int target DTU modbus TCP port 502 microinverter_type MicroinverterType Microinverter type, applies to all microinverters <MicroinverterType.MI: 1> unit_id int Modbus unit ID 1 Source code in hoymiles_modbus/client.py def __init__ ( self , host : str , port : int = 502 , microinverter_type : MicroinverterType = MicroinverterType . MI , unit_id : int = 1 ) -> None : \"\"\"Initialize the object. Arguments: host: DTU address port: target DTU modbus TCP port microinverter_type: Microinverter type, applies to all microinverters unit_id: Modbus unit ID \"\"\" self . _host : str = host self . _port : int = port self . _dtu_serial_number : str = '' self . _microinverter_data_struct : Type [ Union [ MISeriesMicroinverterData , HMSeriesMicroinverterData ]] if microinverter_type == MicroinverterType . MI : self . _microinverter_data_struct = MISeriesMicroinverterData elif microinverter_type == MicroinverterType . HM : self . _microinverter_data_struct = HMSeriesMicroinverterData else : raise ValueError ( 'Unsupported microinverter type:' , microinverter_type ) self . _unit_id = unit_id self . _comm_params : CommunicationParams = CommunicationParams ()","title":"__init__()"},{"location":"api/#hoymiles_modbus.datatypes","text":"Data structures.","title":"datatypes"},{"location":"api/#hoymiles_modbus.datatypes.HMSeriesMicroinverterData","text":"HM series microinverter status data structure. Source code in hoymiles_modbus/datatypes.py class HMSeriesMicroinverterData ( MISeriesMicroinverterData ): \"\"\"HM series microinverter status data structure.\"\"\" pv_current : Decimal = member ( fmt = _udec16p2 , doc = 'PV current [A].' )","title":"HMSeriesMicroinverterData"},{"location":"api/#hoymiles_modbus.datatypes.HMSeriesMicroinverterData.pv_current","text":"PV current [A].","title":"pv_current"},{"location":"api/#hoymiles_modbus.datatypes.MISeriesMicroinverterData","text":"MI series microinverter status data structure. Source code in hoymiles_modbus/datatypes.py class MISeriesMicroinverterData ( Structure ): \"\"\"MI series microinverter status data structure.\"\"\" data_type : int = member ( fmt = uint8 ) serial_number : str = member ( fmt = _serial_number_t , doc = 'Microinverter serial number.' ) port_number : int = member ( fmt = uint8 , doc = 'Port number.' ) pv_voltage : Decimal = member ( fmt = _udec16p1 , doc = 'PV voltage [V].' ) pv_current : Decimal = member ( fmt = _udec16p1 , doc = 'PV current [A].' ) grid_voltage : Decimal = member ( fmt = _udec16p1 , doc = 'Grid voltage [V].' ) grid_frequency : Decimal = member ( fmt = _udec16p2 , doc = 'Grid frequency [Hz].' ) pv_power : Decimal = member ( fmt = _udec16p1 , doc = 'PV power [W].' ) today_production : int = member ( fmt = uint16 , doc = 'Today production [Wh].' ) total_production : int = member ( fmt = uint32 , doc = 'Total production [Wh].' ) temperature : Decimal = member ( fmt = _sdec16p1 , doc = 'Microinverter temperature [\u00b0C].' ) operating_status : int = member ( fmt = uint16 , doc = 'Operating status.' ) alarm_code : int = member ( fmt = uint16 , doc = 'Alarm code.' ) alarm_count : int = member ( fmt = uint16 , doc = 'Alarm count.' ) link_status : int = member ( fmt = uint8 , doc = 'Link status.' ) reserved : List [ int ] = member ( fmt = _reserved )","title":"MISeriesMicroinverterData"},{"location":"api/#hoymiles_modbus.datatypes.MISeriesMicroinverterData.alarm_code","text":"Alarm code.","title":"alarm_code"},{"location":"api/#hoymiles_modbus.datatypes.MISeriesMicroinverterData.alarm_count","text":"Alarm count.","title":"alarm_count"},{"location":"api/#hoymiles_modbus.datatypes.MISeriesMicroinverterData.grid_frequency","text":"Grid frequency [Hz].","title":"grid_frequency"},{"location":"api/#hoymiles_modbus.datatypes.MISeriesMicroinverterData.grid_voltage","text":"Grid voltage [V].","title":"grid_voltage"},{"location":"api/#hoymiles_modbus.datatypes.MISeriesMicroinverterData.link_status","text":"Link status.","title":"link_status"},{"location":"api/#hoymiles_modbus.datatypes.MISeriesMicroinverterData.operating_status","text":"Operating status.","title":"operating_status"},{"location":"api/#hoymiles_modbus.datatypes.MISeriesMicroinverterData.port_number","text":"Port number.","title":"port_number"},{"location":"api/#hoymiles_modbus.datatypes.MISeriesMicroinverterData.pv_current","text":"PV current [A].","title":"pv_current"},{"location":"api/#hoymiles_modbus.datatypes.MISeriesMicroinverterData.pv_power","text":"PV power [W].","title":"pv_power"},{"location":"api/#hoymiles_modbus.datatypes.MISeriesMicroinverterData.pv_voltage","text":"PV voltage [V].","title":"pv_voltage"},{"location":"api/#hoymiles_modbus.datatypes.MISeriesMicroinverterData.serial_number","text":"Microinverter serial number.","title":"serial_number"},{"location":"api/#hoymiles_modbus.datatypes.MISeriesMicroinverterData.temperature","text":"Microinverter temperature [\u00b0C].","title":"temperature"},{"location":"api/#hoymiles_modbus.datatypes.MISeriesMicroinverterData.today_production","text":"Today production [Wh].","title":"today_production"},{"location":"api/#hoymiles_modbus.datatypes.MISeriesMicroinverterData.total_production","text":"Total production [Wh].","title":"total_production"},{"location":"api/#hoymiles_modbus.datatypes.MicroinverterType","text":"Microinverter type. Source code in hoymiles_modbus/datatypes.py class MicroinverterType ( Enum ): \"\"\"Microinverter type.\"\"\" MI = auto () \"\"\"MI series.\"\"\" HM = auto () \"\"\"HM series.\"\"\"","title":"MicroinverterType"},{"location":"api/#hoymiles_modbus.datatypes.MicroinverterType.HM","text":"HM series.","title":"HM"},{"location":"api/#hoymiles_modbus.datatypes.MicroinverterType.MI","text":"MI series.","title":"MI"},{"location":"api/#hoymiles_modbus.datatypes.PlantData","text":"Data structure for the whole plant. Source code in hoymiles_modbus/datatypes.py class PlantData : \"\"\"Data structure for the whole plant.\"\"\" dtu : str \"\"\"DTU serial number.\"\"\" pv_power : Decimal = Decimal ( 0 ) \"\"\"Current production [W].\"\"\" today_production : int = 0 \"\"\"Today production [Wh].\"\"\" total_production : int = 0 \"\"\"Total production [Wh].\"\"\" alarm_flag : bool = False \"\"\"Alarm indicator. True means that at least one microinverter reported an alarm.\"\"\" microinverter_data : List [ Union [ MISeriesMicroinverterData , HMSeriesMicroinverterData ]] = field ( default_factory = list ) \"\"\"Data for each microinverter.\"\"\"","title":"PlantData"},{"location":"api/#hoymiles_modbus.datatypes.PlantData.alarm_flag","text":"Alarm indicator. True means that at least one microinverter reported an alarm.","title":"alarm_flag"},{"location":"api/#hoymiles_modbus.datatypes.PlantData.dtu","text":"DTU serial number.","title":"dtu"},{"location":"api/#hoymiles_modbus.datatypes.PlantData.microinverter_data","text":"Data for each microinverter.","title":"microinverter_data"},{"location":"api/#hoymiles_modbus.datatypes.PlantData.pv_power","text":"Current production [W].","title":"pv_power"},{"location":"api/#hoymiles_modbus.datatypes.PlantData.today_production","text":"Today production [Wh].","title":"today_production"},{"location":"api/#hoymiles_modbus.datatypes.PlantData.total_production","text":"Total production [Wh].","title":"total_production"},{"location":"changelog/","text":"Changelog \u00b6 [0.5.0] (2022-10-03) \u00b6 Add support for low level pymodbus communication parameters. A user can configure additional communication parameters via HoymilesModbusTCP().comm_params [0.4.0] (2022-05-07) \u00b6 Add support for custom Modbus Unit ID Bump plum-py version [0.2.1] (2022-04-23) \u00b6 Again fix handling modbus exceptions - modbus error was causing IndexError: list assignment index out of range exception [0.2.0] (2022-03-15) \u00b6 improve modbus exception handling - now when there is an error in a response then pymodbus exception is raised add support for HM microinverter series - previously pv_current was incorrectly interpreted for these microinverters [0.1.0] (2022-03-12) \u00b6 First release on PyPI.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#050-2022-10-03","text":"Add support for low level pymodbus communication parameters. A user can configure additional communication parameters via HoymilesModbusTCP().comm_params","title":"[0.5.0] (2022-10-03)"},{"location":"changelog/#040-2022-05-07","text":"Add support for custom Modbus Unit ID Bump plum-py version","title":"[0.4.0] (2022-05-07)"},{"location":"changelog/#021-2022-04-23","text":"Again fix handling modbus exceptions - modbus error was causing IndexError: list assignment index out of range exception","title":"[0.2.1] (2022-04-23)"},{"location":"changelog/#020-2022-03-15","text":"improve modbus exception handling - now when there is an error in a response then pymodbus exception is raised add support for HM microinverter series - previously pv_current was incorrectly interpreted for these microinverters","title":"[0.2.0] (2022-03-15)"},{"location":"changelog/#010-2022-03-12","text":"First release on PyPI.","title":"[0.1.0] (2022-03-12)"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/wasilukm/hoymiles_modbus/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 hoymiles_modbus could always use more documentation, whether as part of the official hoymiles_modbus docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/wasilukm/hoymiles_modbus/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up hoymiles_modbus for local development. Fork the hoymiles_modbus repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/hoymiles_modbus.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ poetry run tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8 and 3.9. Check https://github.com/wasilukm/hoymiles_modbus/actions and make sure that the tests pass for all supported Python versions. Tips \u00b6 $ poetry run pytest tests/test_hoymiles_modbus.py To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run: $ poetry run bump2version patch # possible: major / minor / patch $ git push $ git push --tags GitHub Actions will then deploy to PyPI if tests pass.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/wasilukm/hoymiles_modbus/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"hoymiles_modbus could always use more documentation, whether as part of the official hoymiles_modbus docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/wasilukm/hoymiles_modbus/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up hoymiles_modbus for local development. Fork the hoymiles_modbus repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/hoymiles_modbus.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ poetry run tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8 and 3.9. Check https://github.com/wasilukm/hoymiles_modbus/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"$ poetry run pytest tests/test_hoymiles_modbus.py To run a subset of tests.","title":"Tips"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run: $ poetry run bump2version patch # possible: major / minor / patch $ git push $ git push --tags GitHub Actions will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install hoymiles_modbus, run this command in your terminal: $ pip install hoymiles_modbus This is the preferred method to install hoymiles_modbus, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for hoymiles_modbus can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/wasilukm/hoymiles_modbus Or download the tarball : $ curl -OJL https://github.com/wasilukm/hoymiles_modbus/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install hoymiles_modbus, run this command in your terminal: $ pip install hoymiles_modbus This is the preferred method to install hoymiles_modbus, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for hoymiles_modbus can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/wasilukm/hoymiles_modbus Or download the tarball : $ curl -OJL https://github.com/wasilukm/hoymiles_modbus/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"From source"},{"location":"usage/","text":"Usage \u00b6 To use hoymiles_modbus in a project from hoymiles_modbus.client import HoymilesModbusTCP plant_data = HoymilesModbusTCP('1.2.3.4').plant_data print(plant_data.today_production)","title":"Usage"},{"location":"usage/#usage","text":"To use hoymiles_modbus in a project from hoymiles_modbus.client import HoymilesModbusTCP plant_data = HoymilesModbusTCP('1.2.3.4').plant_data print(plant_data.today_production)","title":"Usage"}]}